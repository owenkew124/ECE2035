#=================================================================
# Copyright 2021 Georgia Tech.  All rights reserved.
# The materials provided by the instructor in this course are for
# the use of the students currently enrolled in the course.
# Copyrighted course materials may not be further disseminated.
# This file must not be made publicly available anywhere.
# =================================================================
#
# Locate Part in Pile
#
# P1-2
# Student Name: Owen Kew
# Date: 10/15/2021
#
# This program locates the part in a pile that has a specified color, and
# reports its bounding box: 
# <offset of upper left corner, offset of lower right corner>.
# Offsets are specified as linear offsets from the Pile image base.
#
# SWI I/O:
# Create Pile and Choose Color swi 598 takes Pile base address in $1 and
# returns color to find in $3 and also fills pile array into memory
# starting at base address (1 byte/pixel)
#
# Bounding box is given to Report Part BBox swi 599 in $2:
# as linear offsets from Pile base of bbox corners: [UpperLeft | LowerRight]
# packed into the upper and lower 16 bits of $2.
# Oracle returns correct answer in $3.
#	
# Mark pixel swi 547 takes linear offset from Pile address as input
# and highlights pixel at that offset. Returns nothing.
#
#===========================================================================
# CHANGE LOG: brief description of changes made from P1-2-shell.asm
# to this version of code.
# Date  Modification
# 10/14 Added more checks on the row check portion
# 10/15 Changed from storing the top of the column and left pixel of the row from in registers to in stack memory
# 10/15 Fixed error where could access a memory slot outside of the allocated slots
# 10/15 Changed from storing the top left/bottom right from in registers to in stack memory to consolidate registers
# 10/15 Changed registers at the end to ones that were used before, but haven't been used in a while (in order to use less register overall)
# 10/15 Went through the code and consolidated and got rid of unecessary lines   
# 10/15 Added a Give Up branch if the code cannot find a row
#===========================================================================

.data
Pile:  .alloc	1024

.text

Locate:	addi	$1, $0, Pile		# point to array base

# ***************************************************************************
# Easter egg -- you can use this in debugging to load in a testcase that was
# generated by Misasim earlier and dumped to memory.  Put -1 into $2 and put
# color code (e.g., 4 for blue) into $3 before calling swi 598.
# BE SURE TO COMMENT OUT ALL DEBUGGING FEATURES BEFORE SUBMITTING YOUR CODE
# ***************************************************************************
	swi	598			# create pile and select color
					# $3 holds part color

# ***************************************************************************
# ***************************************************************************
		# Basically what this code does is search down 2 separate 2 pixel wide column 1/3 and 2/3 of the way across the
		# image until it hits a row. It then finds the leftmost part of the row and saves it for later. It then starts
		# to traverse the row until it ends on the right and stores both the width and the rightmost end of the row.
		# Along the way it also checks for a column to search down and after its done with the row traversal, it starts
		# down the column. It finds the top of the column and saves it and traverses down the column to the end.
		# It then finds the pixel row of the top of the column and the pixel column of leftmost pixel of the row and 
		# combines them to get the top left corner and does a similar thing to the bottom of the column and rightmost
		# pixel of the row to get the bottom right corner. It then traverses around the box to see if there is a row/column that
		# was longer than the row/column that was found first and adjusts the corners accordingly and then reports the answer.
										
										# These next two loops traverse down two columns to try and find a row
				addi $7, $0, 64			# Set up to traverse down a column 1/3 of the way across the screen. Sets up $7 as a counter and $6 as an ending point
				addi $6, $0, 4032		# Starts 1 row off the top and ends 1 row off the bottom because there is no need to check there 
				addi $12, $0, 0			# Used later to check which Loop its in (Loop or Loop2)
Loop:   		addi $4, $7, 21			# Sets $4 to the next pixel to be checked in the column
				add  $8, $4, $1			# Puts the address of the pixel needed to be checked into $8
				lb   $2, 0($8)			# Finds the color of the pixel and puts it into $2
				beq  $2, $3, RowFound	# Checks if the color of the pixel is the color that is asked for and if so it breaks to a series of commands to figure out if its a row
				addi $4, $7, 22			# Sets $4 to the next pixel to be checked in the other column
				add  $8, $4, $1			# Puts the address of the pixel needed to be checked into $8
				lb   $2, 0($8)			# Finds the color of the pixel and puts it into $2
				beq  $2, $3, RowFound	# Checks if the color of the pixel is the color that is asked for and if so it breaks to a series of commands to figure out if its a row
				addi $7, $7, 64 		# Increments the counter to get the next row of pixels in the column
				bne  $7, $6, Loop		# If the counter is at the end point, go to the next column 2/3 of the way across the screen. If not, iterate over the loop again.
				
				addi $7, $0, 64			# Sets up the counter for the second column 2/3 of the way across the screen
				addi $12, $0, 1			# Tells the check that it is now going down the column 2/3 of the way across the screen
Loop2:  		addi $4, $7, 42			# Sets $4 to the next pixel to be checked in the column
				add  $8, $4, $1			# Puts the address of the pixel needed to be checked into $8
				lb   $2, 0($8)			# Finds the color of the pixel and puts it into $2
				beq  $2, $3, RowFound	# Checks if the color of the pixel is the color that is asked for and if so it breaks to a series of commands to figure out if its a row
				addi  $4, $7, 43		# Sets $4 to the next pixel to be checked in the other column
				add  $8, $4, $1			# Puts the address of the pixel needed to be checked into $8
				lb   $2, 0($8)			# Finds the color of the pixel and puts it into $2
				beq  $2, $3, RowFound	# Checks if the color of the pixel is the color that is asked for and if so it breaks to a series of commands to figure out if its a row
				addi $7, $7, 64 		# Increments the counter to get the next row of pixels in the column
				bne  $7, $6, Loop2		# If the counter is at the end point, give up. If not, iterate over the loop again.
				beq $7, $6, GiveUp		# Give Up to stop errors
		
				# This part of the code starts when Loop or Loop2 finds a pixel of the same color. The address of the pixel is in $8
RowFound: 		lb $2, 1($8)			# Loads the pixel to the right of the first pixel into $8
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				lb $2, 2($8)			# Loads the pixel to the right of the previous pixel
				bne $2, $3, RowCheck2	# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 3($8)			# Loads the pixel to the right of the previous pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				lb $2, 4($8)			# Loads the pixel to the right of the previous pixel
				bne $2, $3, RowCheck2	# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 5($8)			# Loads the pixel to the right of the previous pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				lb $2, 6($8)			# Loads the pixel to the right of the previous pixel
				bne $2, $3, RowCheck2	# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 7($8)			# Loads the pixel to the right of the previous pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				addi $8, $8, -7			# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 6($8)			# Loads the pixel to the left of the first pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				lb $2, 5($8)			# Loads the pixel to the left of the previous pixel
				bne $2, $3, RowCheck2	# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 4($8)			# Loads the pixel to the left of the previous pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				lb $2, 3($8)			# Loads the pixel to the left of the previous pixel
				bne $2, $3, RowCheck2	# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 2($8)			# Loads the pixel to the left of the previous pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
				lb $2, 1($8)			# Loads the pixel to the left of the previous pixel
				bne $2, $3, RowCheck2	# If this pixel is not the same color of the first pixel then it can't be a row as there cannot be two columns right next to each other occluding the row, so jump to an iterator of Loop/Loop2. If it is the same color, it still has to be checked as its not next to a pixel of the same color.
				lb $2, 0($8)			# Loads the pixel to the left of the previous pixel
				beq $2, $3, Loop3		# Checks if it is the same color (2 next to each other must mean a row). If it is then jump to the row traversal, else continue with the checks.
										
RowCheck2:		addi $7, $7, 64			# Increments $7 for the next loop
				bne $12, $0, Loop2		# Checks if it is a Loop2 pixel
				j Loop					# If its not a Loop2 pixel then go back to Loop1
		
										# This loop starts once the program has found a row and the pixel of the row that was found is in $4
										# This loop aims to find the leftmost part of the row found 
Loop3:			addi $4, $4, -1			# Decrements $4 to find the pixel to the left of the current pixel
				add $8, $4, $1			# Finds the address of this pixel and puts it into $8
				lb $2, 0($8)			# Finds the color of this pixel and puts it into $2
				beq $3, $2, Loop3		# Checks if this pixel is the same color as the color needed, as if it isn't the row might have ended, but if it is then it needs to loop back to get the next pixel as it is still a row
				addi $8, $8, -1			# Decrements the address of the current pixel to get the address of the pixel to the left of the current pixel
				lb $2, 0($8)			# Finds the color of this new pixel and puts it into $2
				beq $3, $2, Loop3		# Checks if this pixel is the same as the color needed because if it isn't then the row definitively has ended. If it is, then it needs to loop back to get the next pixel as it is still a row
				addi $4, $4, 1			# Adjusts the leftmost part of the row as the loop stops when $4 is 1 off of the end of the row
				addi $29, $29, -8		# Prepares to make space for this pixel at the end of the stack memory
				sw $4, 0($29)			# Stores this pixel (leftmost part of the row) at the end of the stack memory
				addi $4, $4, -1			# Adjusts this pixel back to make sure the next loop starts at the right pixel
				addi $7, $0, 0			# Resets $7 as another counter, time to count the width of the row
		
Loop4: 			addi $4, $4, 1			# Increments $4 to go across the row
				add $8, $4, $1			# Finds the address of the pixel at $4 in the row
				addi $7, $7, 1			# Incremnts the width of the row
				beq $6, $0, Continue	# Checks whether a column has been already found. If not try and find one, else continue across the row
				addi $10, $8, 64		# Gets the address of the pixel down a row from where it is and stores it in $10
				lb $2, 0($10)			# Finds the color of this pixel down a row and stores it in $2
				beq $3, $2, Column		# If its the color wanted, then its a column (2 in a row). If not maybe the row is the last row of the columns in this part
				addi $10, $8, -64		# Gets the address of the pixel above the row at this point and stores it in $10
				lb $2, 0($10)			# Finds the color of this pixel and stores it in $2
				bne $3, $2, Continue	# If this is not the same as the color wanted then continue down the row, else it is a column.
				
Column:			addi $6, $0, 0			# Changes $6 to 0 to tell the Loop that a column has already been found
		
Continue:		lb $2, 0($8)			# Finds the color of the pixel at $4 in this part of the row
				beq $3, $2, Loop4		# Checks if this is the same color as the color wanted. If not then it could be occluded, but if so then the row continues (Loop back)
				addi $8, $8, 1			# Finds the address of the pixel to the right of the current pixel in $4
				lb $2, 0($8)			# Finds the color of this new pixel 2 pixels down from $4
				beq $3, $2, Loop4		# Checks if this is the same color as the color wanted. If not then the row has ended (2 non-wanted colors must mean no more row), but if so then the row continues (Loop back)
				add  $13, $0, $4		# Since the row has ended, stores the value of $4 into $13 for use later
				addi $13, $13, -1		# Adjust $13 to the right point as the loop iterates 1 more than needed
				sub $10, $10, $1		# Finds the pixel of the column that was found, from the address (was stored in $10)
				addi $4, $10, 64		# Sets up $4 as an counter to go up the column to find the top of the column (adds 64 to make sure the loop starts at the right pixel)
		
Loop5:			addi $4, $4, -64		# Decrements $4 to continue down the loop
				add $8, $4, $1			# Gets the address of the current pixel and puts it into $8
				lb $2, 0($8)			# Finds the color of this pixel
				beq $3, $2, Loop5		# Checks if this pixel is the same as the color wanted, if so then the column is still going. If not, then it could be occluded
				addi $8, $8, -64		# Decrements the address of the current pixel to find the next pixel down
				slt $2, $8, $1			# Checks if this pixel is not in the image
				bne $2, $0, Continue2	# If so, then the column has ended. If not, then continue to check it
				lb $2, 0($8)			# Gets the color of this pixel
				beq $3, $2, Loop5		# Checks if this pixel is the same as the color wanted, if so then the column is still going. If not, the column has ended
				
										# Once it finds the top of the column it is now time to go down the column to find the bottom and the height (stored in $6 as it was put to 0 in a previous loop)
Continue2:		addi $4, $4, 64			# Adjusts the top to the right pixel
				sw $4, 4($29)			# Stores this value (top of the colum) into stack memory
				addi $4, $4, -64		# Decrements the top to make sure the Loop starts at the right spot

										
Loop6: 			addi $4, $4, 64 		# Increments the Loop to the next pixel in the column
				add $8, $4, $1			# Just like before, it finds the address of this pixel and puts it in $8
				addi $6, $6, 1			# Increments the height 
				lb $2, 0($8)			# Finds the color of this pixel and puts it in $2
				beq $3, $2, Loop6 		# If this is the same color as the one wanted, loop back. If not, it could be occluded
				addi $8, $8, 64			# Finds the address of the next pixel down
				lb $2, 0($8)			# Finds the color of the next pixel down
				beq $3, $2, Loop6		# If this is the same color as the one wanted, loop back. If not, the column has ended 
					
										# Now that most of the looping is done, it is now time to find the corners
Continue3:		addi $2, $4, -64		# Takes the bottom of the column from the latest loop (stored in $4) and makes sure its in the right spot (loop iterates one too many times)
				addi $17, $0, 64		# Puts 64 into $17 for use in dividing later
				lw $8, 0($29)			# Loads the Leftmost part of the row into $8
				lw $10, 4($29)			# Loads the top of the column into $10
				div $10, $17			# Divide the top of the column by 64 for the remainder (which column of pixels the column is in)
				mfhi $12				# Put the remainder into $12
				sub $10, $10, $12		# Subtract the topmost column by the remainder to get the row in which the top is
				div $8, $17				# Divide the leftmost part of the row by 64 for the remainder (which column of pixels the leftmost pixel of the row is)
				mfhi $8					# Put the remainder into $8
				add $8, $8, $10			# Add the row of the top of the column and the column of the leftmost pixel to get the top left corner
				addi $8, $8, -65		# Adjust this value for looping later
				sw $8, 4($29)			# Store the top left into stack memory
				div $13, $17			# $13 stores the rightmost part of the row. Divide that by 64 to get the remainder (the column of pixels that holds this part of the row)
				mfhi $13				# Store this remainder into $13
				sub $2, $2, $12			# Subtract the bottom of the column (stored in $2) from the column of pixels which has the column in it 
				add $13, $13, $2		# Add the row of the bottom of the column and the column of the rightmost pixel of the row to get the bottom right corner
				addi $13, $13, 65		# Adjust this value for looping later
				sw $13, 0($29)			# Store the bottom right corner into stack memory
			
										# These next loops try and find a pixel that is the color wanted one pixel outside of the bounding box as the last pixel of the row/column could have been occluded and thus the row/column would have been counted as 1 less than correct
				lw $17, 0($29)			# Load the bottom right corner into $17
				addi $4, $0, 0			# Set up $4 as a counter
Loop7:			addi $17, $17, -1		# Decrement $17 to get the pixel to the left of the current pixel (right now it is searching the row below the current bounding box
				addi $4, $4, 1			# Increment the counter
				add $2, $17, $1			# Find the address of the current pixel
				lb  $2, 0($2)			# Find the color of the current pixel
				beq $3, $2, ExtraFound1	# Check if this pixel has the same color as the color wanted. If so, then the bottom of our column was occluded. If not, continue searching.
				bne $4, $7, Loop7		# Check if the loop has been running for the same number of iterations as the width. If so there was no extra pixel. If not, continnue searching.
		
Continue4:		addi $4, $0, 0			# Set up a new counter for the next loop
				lw $17, 0($29)			# Load the bottom right corner into $17
Loop8:  		addi $17, $17, -64		# Find the next pixel up from the current pixel (currently searching the column to the right of the bounding box)
				addi $4, $4, 1			# Increment the counter
				add $2, $17, $1			# Find the address of the current pixel
				lb  $2, 0($2)			# Find the color of the current pixel
				beq $2, $3, ExtraFound2	# Check if this pixel has the same color as the color wanted. If so, then the bottom of our column was occluded. If not, continue searching.
				bne $4, $6, Loop8		# Check if the loop has been running for the same number of iterations as the height. If so there was no extra pixel. If not, continnue searching.
			
Continue5:		lw $17, 4($29)			# Load the top left corner into $17
Loop9:			addi $17, $17, 1		# Find the next pixel right of the current pixel (currently searching the row above the bounding box)
				addi $7, $7, -1			# Decrement the width (used in place of a counter because why not)
				add $2, $17, $1			# Find the address of the current pixel
				lb  $2, 0($2)			# Find the color of the current pixel
				beq $3, $2, ExtraFound3	# Check if this pixel has the same color as the color wanted. If so, then the bottom of our column was occluded. If not, continue searching.
				bne $0, $7, Loop9		# Check if the loop has been running for the same number of iterations as the width ($7 = 0). If so there was no extra pixel. If not, continnue searching.
			
Continue6: 		lw $17, 4($29)			# Load the top left corner into $17
Loop0:  		addi $17, $17, 64		# Find the pixel below the current pixel (currently searching the column to the left of the bounding box)
				addi $6, $6, -1			# Decrement the height (used in place of a counter because I wanted to)
				add $2, $17, $1			# Find the address of the current pixel
				lb  $2, 0($2)			# Find the color of the current pixel
				beq $2, $3, ExtraFound4	# Check if this pixel has the same color as the color wanted. If so, then the bottom of our column was occluded. If not, continue searching.
				bne $0, $6, Loop0		# Check if the loop has been running for the same number of iterations as the height ($6 = 0). If so there was no extra pixel. If not, continnue searching.
				j End					# There were no extra pixels in this one and this is the last side to look, so go to packing
		
ExtraFound1:	addi $13, $13, 64		# If the row below the bottom of the bounding box found a wanted pixel, increase the bounding box by 1 more row
				j Continue4				# Continue on to the next search
ExtraFound2:	addi $13, $13, 1		# If the column to the right of the bounding box found a wanted pixel, increase the bounding box by 1 more column in that direction
				j Continue5				# Continue on to the next search
ExtraFound3:	addi $8, $8, -64		# If the row above the top of the bounding box found a wanted pixel, increase the bounding box by 1 more row
				j Continue6				# Continue on to the next search
ExtraFound4:	addi $8, $8, -1			# If the column to the of the bounding box found a wanted pixel, increase the bounding box by 1 more column in that direction
	# pack corners into $2 and report your answer
# ***************************************************************************

End:			addi $2, $8, 65			# Adds the top left to $2 and adjusts it from the loops before
				addi $13, $13, -65		# Adjusts the bottom right from the loops before	
				sll $2, $2, 16			# Shifts $2 to prepare for packing
				or  $2, $2, $13			# Puts the bottom right corner into $2 next to the top left corner
				addi $29, $29, 8		# Makes sure stack memory is put back to its right spot
# ***************************************************************************

	# call report bbox swi
	# oracle returns correct answer in $3
GiveUp: swi	599			# submit answer and check
		jr	$31			# return to caller

